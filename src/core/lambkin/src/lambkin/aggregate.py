# Copyright 2022 Ekumen, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import pandas as pd

from pathlib import Path
from typing import Dict
from typing import Iterable
from typing import List
from typing import Type

from .aggregator import Aggregator
from .evo_aggregator import ApeAggregator
from .evo_aggregator import RpeAggregator
from .timem_aggregator import TimemAggregator


class AggregatorCollection:
    """Represents a collection of aggregators for the same set of
    benchmark runs."""

    def __init__(self):
        self.aggregators: List[Aggregator] = []

    def append(self, aggregator: Aggregator):
        """Appends an already created aggregator."""
        self.aggregators.append(aggregator)

    def compute_statistics(self, functions: Iterable[str]) -> pd.DataFrame:
        """Returns a dataframe with statistics after aggregating results
        by metric."""
        df_metrics_by_run = pd.concat(
            [aggregator.get_dataframe() for aggregator in self.aggregators],
            axis='columns')

        df_stats = df_metrics_by_run.agg(functions).T
        df_stats.index.name = 'metric'
        return df_stats

    def save_plots(self, path: Path, extension: str) -> None:
        """Save plots generated by each aggregator to a given output path."""
        for aggregator in self.aggregators:
            for name, figure in aggregator.generate_figures():
                figure.tight_layout()
                figure.savefig(path / f'plot_{name}.{extension}')


class AggregatorFactory:
    """Represents a factory that can create collections of aggregators based
    on registered metrics."""

    def __init__(self, metrics: Iterable[str]):
        self.aggregator_metrics: Dict[Type[Aggregator], Iterable[str]] = {}

        metric_set = set(metrics)
        for aggregator_type in Aggregator.subclasses:
            matched_metrics = metric_set.intersection(aggregator_type.get_supported_metrics())
            if matched_metrics:
                self.aggregator_metrics[aggregator_type] = matched_metrics
                metric_set.difference_update(matched_metrics)

        if metric_set:
            raise ValueError(f'Metrics not supported by any aggregator: {metric_set}')

    def create_aggregators(self, dirpaths: Iterable[Path]) -> AggregatorCollection:
        """Creates a collection of aggregators for a set of benchmark runs."""
        aggregators = AggregatorCollection()
        for aggregator_type, metrics in self.aggregator_metrics.items():
            aggregators.append(aggregator_type(metrics, dirpaths))

        return aggregators


def get_parser() -> argparse.ArgumentParser:
    """Returns a command-line argument parser for this program."""
    supported_metrics = Aggregator.get_all_supported_metrics()

    parser = argparse.ArgumentParser(
        description='Result aggregation CLI for LAMBKIN')
    parser.add_argument(
        '-m', '--metrics', choices=supported_metrics, nargs='+', metavar='METRIC',
        default=supported_metrics, help=(
            'Metrics to aggregate. It defaults to all available metrics: %(choices)s.'))
    parser.add_argument(
        '-f', '--functions', type=str, nargs='+',
        default=['median', 'mean', 'std'], help=(
            'Functions to use for aggregating the data. '
            'It defaults to median, mean and std.'))
    parser.add_argument(
        '-o', '--output-path', default=Path.cwd(), help=(
            'Full path to output directory. '
            'It defaults to the current working directory.'))
    parser.add_argument(
        '-p', '--plot-extension', default='svg', help=(
            'Extension of output plots. '
            'It defaults to svg.'))
    parser.add_argument(
        'input', type=Path, nargs='+', help=(
            'Input directory paths containing results for each '
            'iteration to aggregate.'))
    return parser


def main(args) -> None:
    factory = AggregatorFactory(args.metrics)
    aggregators = factory.create_aggregators(args.input)

    df_stats = aggregators.compute_statistics(args.functions)

    results_path = args.output_path / 'metrics.csv'
    df_stats.to_csv(results_path, mode='a', float_format='%.4g', header=not results_path.exists())

    aggregators.save_plots(args.output_path, args.plot_extension)
